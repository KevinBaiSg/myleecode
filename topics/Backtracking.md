# 回溯法  

回溯法（英语：backtracking）是暴力搜索法中的一种。

对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。

在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

* 找到一个可能存在的正确的答案

* 在尝试了所有可能的分步方法后宣告该问题没有答案

在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

## 概念

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 `回溯` 返回，尝试别的路径。  

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 `回溯点`。

许多复杂的，规模较大的问题都可以使用回溯法，有 `通用解题方法` 的美称。

## 基本思想

在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（**其实回溯法就是对隐式图的深度优先搜索算法**）。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

### 用回溯法解题的一般步骤

1. 针对所给问题，确定问题的解空间：  
  首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

2. 确定结点的扩展搜索规则

3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

## 算法框架

* 问题框架  

设问题的解是一个n维向量 (a1,a2,………,an) ,约束条件是 ai(i=1,2,3,…..,n) 之间满足某种条件，记为 f(ai) 。

* 非递归回溯框架  

```c
int a[n],i;
// 初始化数组a[];

i = 1;
while (i>0(有路可走) and (未达到目标)) { // 还未回溯到头
  if(i > n) { // 搜索到叶结点
    // 搜索到一个解，输出；
  } else {  // 处理第i个元素
    // a[i] 第一个可能的值；
    while(a[i]在不满足约束条件且在搜索空间内) {
      // a[i]下一个可能的值；
    }
    if(a[i]在搜索空间内) {
      // 标识占用的资源；
      i = i+1;  // 扩展下一个结点
    } else {
      // 清理所占的状态空间； // 回溯
      i = i – 1;
    }
  }
}
```

* 递归的算法框架

回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：

```c
int a[n];
try(int i)
{
    if(i>n)
       输出结果;
     else
    {
       for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径
       {
           if(fun(j))                 // 满足限界函数和约束条件
             {
                a[i] = j;
              ...                         // 其他操作
                try(i+1);
              回溯前的清理工作（如a[i]置空值等）;
              }
         }
     }
}
```

## 典型应用

1. 八皇后问题是应用回溯法求解的典型案例。

2. [Letter Combinations of a Phone Number](https://github.com/KevinBaiSg/myleecode/tree/master/0017_Letter_Combinations_of_a_Phone_Number)

## 参考文章

1. [五大常用算法之四：回溯法](https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html)  
